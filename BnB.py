# -*- coding: utf-8 -*-
"""
Created on Sat Mar 26 19:53:42 2016

@author: krishna
"""
import numpy as np
import math



# Inputs as A- 1XN vector 
#           b- scalar
#           c - 1XN vector
#          X_up - Upperbound (interger value) of X in order
#          X_lo - Lower bounds (interger value)  of X in order
def LPsolve(A,b,c,X_up,X_lo):
    # bang for the buck algorithm to solve LPs generated by the BnB algorithm
    import numpy as np
    
    flag = 500
    
    OptA_lo = np.multiply(A,X_lo)
    X_diff = np.subtract(X_up,X_lo)
    
    if min(X_diff) < 0:
        return 'infeasible'
    OptA = np.multiply(A,X_diff)
    
    if sum(OptA_lo) > b:
        
        return 'infeasible'
    elif sum(OptA_lo) == b:
        return X_lo
    else:
        
        b = b - sum(OptA_lo)
        
        OptB = []
        for count1 in range(len(A)):
        
            if count1 == 0:
                OptB.append(OptA[count1])
            else:
                OptB.append(OptB[count1-1]+OptA[count1])
    
        for count2 in range(len(OptB)-1):
        
            if OptB[count2] <= b and OptB[count2+1] > b :
                flag = 1
                break
            elif OptB[count2] > b and count2 ==0:
                flag = 0
                break
        Xopt = [X_lo[i] for i in range(len(A))]      
        
        if flag == 1:
            
            for count3 in range(0,count2+1):
                Xopt[count3] = Xopt[count3] + X_diff[count3]
                
            Xopt[count2+1] = Xopt[count2+1] + ((b-OptB[count2])/float((A[count2+1])))
            
            
        elif flag == 0:
            Xopt[count2] = Xopt[count2]+ ((b-OptB[count2])/float((A[count2])))
        
    
        return Xopt
    

size = 100
A = list(np.random.randint(1,11,size))
c = list(np.random.randint(5,51,size))
X_up = list(np.random.randint(1,4,size))

X_lo = [0 for i in range(0,size)]
b = math.floor(sum(A)/1.5)


RatioMat = list(np.true_divide(c,A))

#we reorder the A,c such that c1/A1 >= c2/A2 >= .....
for ind1 in range(0,len(A)-1):
        
        for ind2 in range(ind1+1,len(A)):
            
            if RatioMat[ind1] < RatioMat[ind2]:

			temp = A[ind2]
			A[ind2] = A[ind1]
			A[ind1] = temp
   
   			temp2 = c[ind2]
			c[ind2] = c[ind1]
			c[ind1] = temp2

   			temp3 = X_up[ind2]
			X_up[ind2] = X_up[ind1]
			X_up[ind1] = temp3

   			temp4 = X_lo[ind2]
			X_lo[ind2] = X_lo[ind1]
			X_lo[ind1] = temp4                


   			temp5 = RatioMat[ind2]
			RatioMat[ind2] = RatioMat[ind1]
			RatioMat[ind1] = temp5                 

print 'A is :', A
print 'b is :', b
print 'c is :', c
print 'X_up :', X_up
print 'X_lo:', X_lo

import time
start_time = time.time() 
# We definae a set which will include all the LPs to be solved as we proceed
ProblemSet = []
IncumbentSol = []

ProblemSet.append([A,b,c,X_up,X_lo])
BnBNodes = 1

loop = 0

# While the problemset is not empty we pick one problem from the set and solve it
# If that problem is infeasible then we discard that problem and pick one more fom the set
# If the problem has integer soltion then we check if it is better than the incumbent integer solution
# If the problem has non integer solution but the relaxed problem objective is less than the Incumbent solution objective we prune the node
# If the problem has non intege solution and the objctive is more than the objective of incumbent solution then we generate two new subproblems and add them to the 
# problemset
while len(ProblemSet) <>0 :
    

    loop = loop+1
    
    k = ProblemSet.pop()
    Xout = LPsolve(k[0],k[1],k[2],k[3],k[4])
    
    if Xout <> 'infeasible':
        Xout_frac = [math.modf(i)[0] for i in Xout]
    
    if Xout == 'infeasible':
        if len(ProblemSet) == 0:
            print "The problem is infeasible"
        else:
            pass
    elif max(Xout_frac) == 0:
        if IncumbentSol == []:
            IncumbentSol = Xout[:]
        #update the incumbent integer solution only if it has higher objective value
        # update only if the new solution is better than the existing one
        elif sum(np.multiply(Xout,c)) > sum(np.multiply(IncumbentSol,c)):
            IncumbentSol = Xout[:]
        else:
            pass
        
    elif max(Xout_frac) >0:
        
        if len(ProblemSet) == 0 and loop == 1:
            LPBound = sum(np.multiply(Xout,c))
            LPSol = Xout[:]
            
        # If the current LP relaxed soltion gives a lesser objective than the incumbent integer solution we fathom the node
        # Prune by bound
        if  IncumbentSol <> [] and sum(np.multiply(Xout,c)) <= sum(np.multiply(IncumbentSol,c)):
            pass
        
        # Else we will add these problems to out problemSet
        else:
        
            # branching
            for i in range(0,len(Xout)):
            
                if math.modf(Xout[i])[0] > 0:
                    X_up_child1 = k[3][:]
                    X_lo_child1 = k[4][:]
                
                    X_up_child1[i] = math.floor(Xout[i])
                    
                    X_up_child2 = k[3][:]
                    X_lo_child2 = k[4][:]
                
                    X_lo_child2[i] = math.ceil(Xout[i])
                
                    ProblemSet.append([A,b,c,X_up_child1,X_lo_child1])
                    ProblemSet.append([A,b,c,X_up_child2,X_lo_child2])
                    
                    BnBNodes = BnBNodes+2

if IncumbentSol <> []:

    end_time = time.time()
    
    print 'The optimal solution is:', IncumbentSol
    print 'The optimal objective is:', sum(np.multiply(IncumbentSol,c))
    print 'Total BnB Nodes are:' , BnBNodes
    print 'Solution of LP relaxation:', LPSol
    print 'Objective value for LP relaxation:', LPBound
    print 'Total time taken to solve in ms:', (end_time-start_time)*1000    
    
